from django.contrib.auth.models import User
from django.contrib.auth import authenticate
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json
from .models import FriendRequest, UserProfile, StudyEvent, EventInvitation, DeclinedInvitation



@csrf_exempt
def register_user(request):
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            username = data.get("username")
            password = data.get("password")

            # ‚úÖ Ensure we no longer check for email
            if not username or not password:
                return JsonResponse({"success": False, "message": "Username and Password required."}, status=400)

            if User.objects.filter(username=username).exists():
                return JsonResponse({"success": False, "message": "Username already exists."}, status=400)

            # ‚úÖ Create user without email
            user = User.objects.create_user(username=username, password=password)
            return JsonResponse({"success": True, "message": "User registered successfully."}, status=201)

        except json.JSONDecodeError:
            return JsonResponse({"success": False, "message": "Invalid JSON data."}, status=400)

    return JsonResponse({"success": False, "message": "Invalid request method."}, status=405)

# ‚úÖ Login User
@csrf_exempt  # Remove in production
def login_user(request):
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            username = data.get("username")
            password = data.get("password")

            if not username or not password:
                return JsonResponse({"success": False, "message": "Username and password are required."}, status=400)

            user = authenticate(username=username, password=password)

            if user is not None:
                return JsonResponse({"success": True, "message": "Login successful."}, status=200)
            else:
                return JsonResponse({"success": False, "message": "Invalid credentials."}, status=401)

        except json.JSONDecodeError:
            return JsonResponse({"success": False, "message": "Invalid JSON data."}, status=400)

    return JsonResponse({"success": False, "message": "Invalid request method."}, status=405)




# ‚úÖ Send Friend Request
@csrf_exempt  # Remove in production
def send_friend_request(request):
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            from_username = data.get("from_user")
            to_username = data.get("to_user")

            if not from_username or not to_username:
                return JsonResponse({"success": False, "message": "Both usernames required"}, status=400)

            from_user = User.objects.get(username=from_username)
            to_user = User.objects.get(username=to_username)

            if from_user == to_user:
                return JsonResponse({"success": False, "message": "Cannot send request to yourself"}, status=400)

            if FriendRequest.objects.filter(from_user=from_user, to_user=to_user).exists():
                return JsonResponse({"success": False, "message": "Friend request already sent"}, status=400)

            FriendRequest.objects.create(from_user=from_user, to_user=to_user)
            return JsonResponse({"success": True, "message": "Friend request sent successfully"}, status=201)

        except User.DoesNotExist:
            return JsonResponse({"success": False, "message": "User not found"}, status=404)
        except json.JSONDecodeError:
            return JsonResponse({"success": False, "message": "Invalid JSON format"}, status=400)

    return JsonResponse({"success": False, "message": "Invalid request method."}, status=405)

@csrf_exempt
def logout_user(request):
    if request.method == "POST":
        return JsonResponse({"success": True, "message": "Logout successful."}, status=200)

    return JsonResponse({"success": False, "message": "Invalid request method."}, status=405)


from django.contrib.auth.models import User


@csrf_exempt
def get_all_users(request):
    if request.method == "GET":
        users = list(User.objects.values_list("username", flat=True))  # Get all usernames
        return JsonResponse(users, safe=False)
    
    return JsonResponse({"error": "Invalid request method"}, status=405)

from django.http import JsonResponse
from .models import FriendRequest



from django.http import JsonResponse
from django.contrib.auth.models import User
from .models import UserProfile

from django.http import JsonResponse
from django.shortcuts import get_object_or_404
from django.contrib.auth.models import User

from django.http import JsonResponse
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404
from myapp.models import UserProfile

from django.http import JsonResponse
from django.contrib.auth.models import User

from django.http import JsonResponse
from django.contrib.auth.models import User

def get_friends(request, username):
    try:
        # Log the request
        print(f"üîç Fetching friends for user: {username}")
        
        # Get the user
        user = User.objects.get(username=username)
        
        # Get the user's friends
        friends = list(user.userprofile.friends.values_list("user__username", flat=True))
        
        # Log the found friends
        print(f"‚úÖ Found {len(friends)} friends for {username}: {friends}")
        
        return JsonResponse({"friends": friends})
    except User.DoesNotExist:
        print(f"‚ùå User not found: {username}")
        return JsonResponse({"friends": []})
    except Exception as e:
        print(f"‚ùå Error fetching friends for {username}: {str(e)}")
        return JsonResponse({"error": str(e)}, status=500)
        
from django.http import JsonResponse
from django.contrib.auth.models import User
from myapp.models import FriendRequest

def get_pending_requests(request, username):
    try:
        user = User.objects.get(username=username)

        # ‚úÖ Filter only requests that are **still pending**
        pending_requests = FriendRequest.objects.filter(to_user=user).values_list("from_user__username", flat=True)
        print("Pending Requests",pending_requests)
        return JsonResponse({"pending_requests": list(pending_requests)})
    except User.DoesNotExist:
        return JsonResponse({"error": "User not found."}, status=404)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

# ‚úÖ Fetch Sent Friend Requests (Requests you have sent)
from django.http import JsonResponse
from django.contrib.auth.models import User
from myapp.models import FriendRequest

def get_sent_requests(request, username):
    try:
        print(f"üì© Fetching sent friend requests for: {username}")  # ‚úÖ Debugging Line
        user = User.objects.get(username=username)
        sent_requests = FriendRequest.objects.filter(from_user=user).values_list("to_user__username", flat=True)
        
        print(f"‚úÖ Sent Friend Requests Found: {list(sent_requests)}")  # ‚úÖ Debugging Line
        
        return JsonResponse({"sent_requests": list(sent_requests)})
    except User.DoesNotExist:
        print(f"‚ùå Error: User {username} not found.")  # ‚úÖ Debugging Line
        return JsonResponse({"error": "User not found."}, status=404)
    except Exception as e:
        print(f"‚ùå Server Error: {str(e)}")  # ‚úÖ Debugging Line
        return JsonResponse({"error": str(e)}, status=500)

import json
from django.http import JsonResponse
from django.contrib.auth.models import User
from django.views.decorators.csrf import csrf_exempt
from myapp.models import FriendRequest, UserProfile

import json
from django.http import JsonResponse
from django.contrib.auth.models import User
from django.views.decorators.csrf import csrf_exempt
from myapp.models import FriendRequest, UserProfile

@csrf_exempt
def accept_friend_request(request):
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            from_username = data.get("from_user")
            to_username = data.get("to_user")

            print(f"üîç Processing friend request acceptance: {from_username} -> {to_username}")

            # ‚úÖ Fetch users
            from_user = User.objects.get(username=from_username)
            to_user = User.objects.get(username=to_username)

            # ‚úÖ Fetch friend request
            friend_request = FriendRequest.objects.filter(from_user=from_user, to_user=to_user).first()
            if not friend_request:
                print(f"‚ùå Friend request not found from {from_username} to {to_username}")
                return JsonResponse({"error": "Friend request not found"}, status=404)

            # ‚úÖ Fetch or create user profiles
            from_user_profile, _ = UserProfile.objects.get_or_create(user=from_user)
            to_user_profile, _ = UserProfile.objects.get_or_create(user=to_user)

            # ‚úÖ Add to friends list (both directions)
            from_user_profile.friends.add(to_user_profile)
            to_user_profile.friends.add(from_user_profile)

            # ‚úÖ Verify the friendship was created correctly
            from_friends = list(from_user_profile.friends.all().values_list('user__username', flat=True))
            to_friends = list(to_user_profile.friends.all().values_list('user__username', flat=True))
            
            print(f"‚úÖ {from_username}'s friends: {from_friends}")
            print(f"‚úÖ {to_username}'s friends: {to_friends}")

            # ‚úÖ Confirm database save
            from_user_profile.save()
            to_user_profile.save()

            # ‚úÖ Delete friend request and confirm deletion
            friend_request.delete()
            if not FriendRequest.objects.filter(from_user=from_user, to_user=to_user).exists():
                print(f"‚úÖ Friend request deleted successfully for {from_username} -> {to_username}")

            return JsonResponse({
                "success": True, 
                "message": f"{from_username} and {to_username} are now friends.",
                "from_user_friends": from_friends,
                "to_user_friends": to_friends
            }, status=200)

        except User.DoesNotExist as e:
            print(f"‚ùå User not found error: {str(e)}")
            return JsonResponse({"error": "User not found"}, status=404)
        except json.JSONDecodeError:
            print("‚ùå Invalid JSON data")
            return JsonResponse({"error": "Invalid JSON data"}, status=400)
        except Exception as e:
            print(f"‚ùå Unexpected error: {str(e)}")
            return JsonResponse({"error": str(e)}, status=500)

    return JsonResponse({"error": "Invalid request method."}, status=405)



def chat_room(request, room_name):
    return render(request, "chat/chat.html", {"room_name": room_name})


from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.models import User
from .models import StudyEvent
import json
from datetime import datetime

import json
from datetime import datetime
from django.http import JsonResponse
from django.contrib.auth.models import User
from .models import StudyEvent

@csrf_exempt
def create_study_event(request):
    """Modified to include auto-matching in the same transaction"""
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            host = get_object_or_404(User, username=data.get("host"))

            # Extract fields for auto-matching
            interest_tags = data.get("interest_tags", [])
            max_participants = data.get("max_participants", 10)
            auto_matching_enabled = data.get("auto_matching_enabled", False)
            
            # Create the event
            event = StudyEvent.objects.create(
                title=data.get("title") or "Untitled Event",  # Ensure title is never None
                description=data.get("description", ""),
                host=host,
                latitude=data.get("latitude"),
                longitude=data.get("longitude"),
                time=datetime.fromisoformat(data.get("time")),
                end_time=datetime.fromisoformat(data.get("end_time")),
                is_public=data.get("is_public", True),
                event_type=data.get("event_type", "other"),
                max_participants=max_participants,
                auto_matching_enabled=auto_matching_enabled,
            )
            
            # Set interest tags
            if hasattr(event, 'set_interest_tags'):
                event.set_interest_tags(interest_tags)
            
            # Add invited friends
            # Add invited friends
            invited_friends = data.get("invited_friends", [])
            for friend in invited_friends:
                friend_user = User.objects.get(username=friend)
                # Add to M2M field
                event.invited_friends.add(friend_user)
                # Create direct invitation record
                EventInvitation.objects.create(
                    event=event,
                    user=friend_user,
                    is_auto_matched=False
                )

            event.save()
            
            # IMPORTANT: Log the created event ID for verification
            print(f"‚úÖ Created event with ID: {event.id}")
            
            # If auto-matching is enabled, do it now in the same transaction
            matched_users = []
            invites_sent = 0
            
            if auto_matching_enabled:
                print(f"üîç Auto-matching for event {event.id}...")
                try:
                    # Get potential matches
                    potential_users = UserProfile.objects.filter(auto_invite_enabled=True) \
                        .exclude(user=host) \
                        .exclude(user__in=event.invited_friends.all()) \
                        .exclude(user__in=event.attendees.all())
                    
                    # Process matches (simplified version)
                    for profile in potential_users:
                        # Get user interests
                        user_interests = []
                        if hasattr(profile, 'get_interests'):
                            user_interests = profile.get_interests()
                        
                        # Add to matches
                        matching_interests = set(user_interests).intersection(set(interest_tags))
                        if matching_interests:
                            user = profile.user
                            # Add to invited friends but mark as auto-matched
                            # Create auto-matched invitation record
                            EventInvitation.objects.create(
                                event=event,
                                user=user,
                                is_auto_matched=True
                            )
                            invites_sent += 1
                            matched_users.append({
                                "username": user.username,
                                "matching_interests": list(matching_interests)
                            })
                    
                    print(f"‚úÖ Auto-matched and invited {invites_sent} users")
                except Exception as e:
                    print(f"‚ùå Error during auto-matching: {str(e)}")
            
            return JsonResponse({
                "success": True, 
                "event_id": str(event.id),
                "auto_matching_results": {
                    "enabled": auto_matching_enabled,
                    "invites_sent": invites_sent,
                    "matched_users": matched_users
                }
            }, status=201)

        except Exception as e:
            print(f"‚ùå Error creating event: {str(e)}")
            import traceback
            traceback.print_exc()
            return JsonResponse({"error": str(e)}, status=500)


from django.contrib.auth.models import User
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.utils import timezone  # Add this import
from .models import StudyEvent, DeclinedInvitation  # Add DeclinedInvitation

@csrf_exempt
def get_study_events(request, username):
    try:
        user = User.objects.get(username=username)
        friend_list = list(user.userprofile.friends.values_list("user__username", flat=True))
        
        # Get the basic sets of events
        public_events = StudyEvent.objects.filter(is_public=True)
        friend_events = StudyEvent.objects.filter(host__username__in=friend_list)
        user_events = StudyEvent.objects.filter(host=user)
        # Add this query to get events where the user is invited
        invited_events = StudyEvent.objects.filter(
            invitation_records__user=user
        ).exclude(is_public=True)  # Only get private ones since public are already included
        
        # Then include in the union
        events = (public_events | friend_events | user_events | invited_events).distinct()
        
        # Get IDs of events that the user has declined
        declined_event_ids = DeclinedInvitation.objects.filter(user=user).values_list('event_id', flat=True)
        
        # Exclude events that have been declined
        events = events.exclude(id__in=declined_event_ids)
        
        # Exclude events where the user is only invited but has not accepted
        filtered_events = []
        for event in events:
            # Skip events where user is only invited but not attending and not the host
            # AND there's no matching invitation record for this user
            if (event.invited_friends.filter(username=username).exists() and 
                not event.attendees.filter(username=username).exists() and 
                event.host.username != username and 
                not EventInvitation.objects.filter(event=event, user=user).exists()):
                continue
                
            # Also skip events that have already ended
            if event.end_time <= timezone.now():
                continue
                
            filtered_events.append(event)
        
        # Format event data for response
        event_data = []
        for event in filtered_events:
            # Check if event_type is None and provide a default
            event_type = event.event_type
            if event_type is None or event_type == "":
                event_type = "other"
            
            print(f"DEBUG: Processing event {event.id} - Type: {event_type}")
            
            # Inside the event_data.append part of get_study_events
            event_data.append({
                "id": str(event.id),
                "title": event.title,
                "description": event.description or "",
                "latitude": event.latitude,
                "longitude": event.longitude,
                "time": event.time.isoformat(),
                "end_time": event.end_time.isoformat(),
                "host": event.host.username,
                "hostIsCertified": event.host.userprofile.is_certified,
                "isPublic": event.is_public,
                "event_type": event_type.lower(),  # Ensure it's always lowercase
                "invitedFriends": list(event.invited_friends.values_list("username", flat=True)),
                "attendees": list(event.attendees.values_list("username", flat=True)),
                # Add these new fields to the response
                "max_participants": event.max_participants,
                "auto_matching_enabled": event.auto_matching_enabled,
                "interest_tags": event.get_interest_tags() if hasattr(event, 'get_interest_tags') else [],
            })
        return JsonResponse({"events": event_data}, safe=False)
    except User.DoesNotExist:
        return JsonResponse({"error": "User not found"}, status=404)
    except Exception as e:
        print(f"ERROR in get_study_events: {str(e)}")
        return JsonResponse({"error": str(e)}, status=500)

        
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json

import json
import uuid
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from uuid import UUID
from .models import User, StudyEvent

import uuid
import json
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from .models import User, StudyEvent

import uuid
import json
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from .models import User, StudyEvent  # Assuming you have a User and StudyEvent model.
import uuid
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from .models import StudyEvent, User

@csrf_exempt
def rsvp_study_event(request):
    if request.method == "POST":
        print("Request Body:", request.body.decode('utf-8'))
        try:
            data = json.loads(request.body)
            username = data.get("username")
            event_id = data.get("event_id")

            # Convert the event_id to lowercase and ensure it's a valid UUID
            try:
                event_uuid = uuid.UUID(event_id.lower())
                print(f"Converted event_id: {event_uuid}")
            except ValueError:
                print("Invalid event_id format")
                return JsonResponse({"error": "Invalid event_id format"}, status=400)

            # Try to fetch the event using the UUID
            try:
                event = StudyEvent.objects.get(id=event_uuid)
                print(f"Fetched event: {event}")
            except StudyEvent.DoesNotExist:
                print(f"StudyEvent with ID {event_uuid} not found.")
                return JsonResponse({"error": "Event not found"}, status=404)

            # Fetch user
            user = User.objects.get(username=username)
            print(f"Fetched user: {user.username}")

            # Check if the user is already an attendee
            if user in event.attendees.all():
                print(f"{user.username} is already attending the event, removing...")
                event.attendees.remove(user)  # Leave event
                event_data = {
                    "id": str(event.id),
                    "title": event.title,
                    "event_type": event.event_type.lower(),  # Ensure lowercase
                }
                return JsonResponse({
                    "success": True, 
                    "message": "Left the event",
                    "event": event_data
                }, status=200)
            else:
                print(f"{user.username} is not attending the event, adding...")
                event.attendees.add(user)  # Join event
                
                # IMPORTANT FIX: Remove invitation when they join
                try:
                    invitation = EventInvitation.objects.get(event=event, user=user)
                    invitation.delete()
                    print(f"Deleted invitation for {user.username} since they joined the event")
                except EventInvitation.DoesNotExist:
                    print(f"No invitation found for {user.username} for this event")
                
                event_data = {
                    "id": str(event.id),
                    "title": event.title,
                    "event_type": event.event_type.lower(),  # Ensure lowercase
                }
                return JsonResponse({
                    "success": True, 
                    "message": "Joined the event",
                    "event": event_data
                }, status=200)

        except User.DoesNotExist:
            print("User not found.")
            return JsonResponse({"error": "User not found"}, status=404)
        except ValueError:
            print("Invalid event_id format.")
            return JsonResponse({"error": "Invalid event_id format"}, status=400)
        except Exception as e:
            print(f"‚ùå Error in RSVP: {str(e)}")
            return JsonResponse({"error": str(e)}, status=500)

    return JsonResponse({"error": "Invalid request method"}, status=405)

@csrf_exempt
def delete_study_event(request):
    """
    POST request with JSON:
    {
      "username": "Alice",
      "event_id": "<UUID-string>"
    }
    Only the host of the event can delete it.
    """
    if request.method == "POST":
        data = json.loads(request.body)
        username = data.get("username")
        event_id = data.get("event_id")

        try:
            event_uuid = uuid.UUID(event_id)
        except ValueError:
            return JsonResponse({"error": "Invalid event_id format"}, status=400)

        try:
            event = StudyEvent.objects.get(id=event_uuid)
        except StudyEvent.DoesNotExist:
            return JsonResponse({"error": "Event not found"}, status=404)

        # Check if the user is actually the host
        if event.host.username != username:
            return JsonResponse({"error": "Only the host can delete this event"}, status=403)

        event.delete()
        return JsonResponse({"success": True, "message": "Event deleted successfully"}, status=200)

    return JsonResponse({"error": "Invalid request method"}, status=405)


def get_user_profile(request, username):
    try:
        user = User.objects.get(username=username)
        userprofile = user.userprofile
        
        # Get interests if available or provide empty list
        interests = []
        if hasattr(userprofile, 'get_interests'):
            interests = userprofile.get_interests()
        
        # Get skills if available or provide empty map  
        skills = {}
        if hasattr(userprofile, 'get_skills'):
            skills = userprofile.get_skills()
        
        # Get auto invite preference with default
        auto_invite_enabled = getattr(userprofile, 'auto_invite_enabled', True)
        
        # Get preferred radius with default
        preferred_radius = getattr(userprofile, 'preferred_radius', 10.0)
        
        return JsonResponse({
            "username": user.username,
            "is_certified": userprofile.is_certified,
            "interests": interests,
            "skills": skills,
            "auto_invite_enabled": auto_invite_enabled,
            "preferred_radius": preferred_radius
        })
    except User.DoesNotExist:
        return JsonResponse({"error": "User not found"}, status=404)
    except Exception as e:
        print(f"‚ùå Error getting user profile: {str(e)}")
        return JsonResponse({"error": str(e)}, status=500)

@csrf_exempt
def search_events(request):
    if request.method == "GET":
        query = request.GET.get("query", "")
        public_only = request.GET.get("public_only", "false").lower() == "true"
        certified_only = request.GET.get("certified_only", "false").lower() == "true"

        qs = StudyEvent.objects.all()

        # If user typed a text query, match event titles
        if query:
            from django.db.models import Q
            qs = qs.filter(Q(title__icontains=query))

        # If user wants only public events
        if public_only:
            qs = qs.filter(is_public=True)

        # If user wants events from certified hosts
        if certified_only:
            qs = qs.filter(host__userprofile__is_certified=True)

        # Build JSON
        data = []
        for event in qs:
            data.append({
                "id": str(event.id),
                "title": event.title,
                "latitude": event.latitude,
                "longitude": event.longitude,
                "time": event.time.isoformat(),
                "end_time": event.end_time.isoformat(),
                "host": event.host.username,
                "isPublic": event.is_public,
                # ...
            })

        return JsonResponse({"events": data}, safe=False)

    return JsonResponse({"error": "Invalid request method"}, status=405)


from sentence_transformers import SentenceTransformer
import numpy as np

def semantic_search(query, events):
    model = SentenceTransformer('all-MiniLM-L6-v2')
    
    # Embed query and events
    query_embedding = model.encode(query)
    event_embeddings = [model.encode(event.title + " " + (event.description or "")) for event in events]
    
    # Compute similarities
    similarities = [np.dot(query_embedding, emb) for emb in event_embeddings]
    
    # Rank events by similarity
    ranked_events = sorted(zip(events, similarities), key=lambda x: x[1], reverse=True)
    
    return [event for event, _ in ranked_events[:5]]  # Top 5 semantically similar events


from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse
import json
from django.contrib.auth.models import User

from django.core.cache import cache
from django.db.models import Q
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from .models import StudyEvent
import json
import uuid
import numpy as np
from sentence_transformers import SentenceTransformer

# Load the model once at the module level
MODEL = SentenceTransformer('all-MiniLM-L6-v2')

def get_event_embedding(event):
    """
    Returns the embedding for an event's title and description.
    Caches the embedding to avoid re-computation.
    """
    cache_key = f'event_embedding_{event.id}'
    embedding = cache.get(cache_key)
    if embedding is None:
        text = f"{event.title} {event.description or ''}"
        embedding = MODEL.encode(text, convert_to_numpy=True)
        cache.set(cache_key, embedding, timeout=3600)  # Cache for 1 hour
    return embedding

def semantic_search(query, events):
    """
    Performs semantic search over the given events based on the query.
    Returns the top 5 events ranked by cosine similarity.
    """
    # Compute embedding for the query
    query_embedding = MODEL.encode(query, convert_to_numpy=True)
    similarities = []
    
    for event in events:
        emb = get_event_embedding(event)
        # Calculate cosine similarity
        sim = np.dot(query_embedding, emb) / (np.linalg.norm(query_embedding) * np.linalg.norm(emb))
        similarities.append(sim)
    
    # Sort events by similarity score (highest first)
    ranked_events = sorted(zip(events, similarities), key=lambda x: x[1], reverse=True)
    top_events = [event for event, sim in ranked_events[:5]]
    return top_events

@csrf_exempt
def enhanced_search_events(request):
    if request.method == "GET":
        query = request.GET.get("query", "")
        public_only = request.GET.get("public_only", "false").lower() == "true"
        certified_only = request.GET.get("certified_only", "false").lower() == "true"
        event_type = request.GET.get("event_type", "").lower()
        use_semantic = request.GET.get("semantic", "false").lower() == "true"

        qs = StudyEvent.objects.all()

        # Basic search filtering
        if query:
            qs = qs.filter(Q(title__icontains=query) | Q(description__icontains=query))
        if public_only:
            qs = qs.filter(is_public=True)
        if certified_only:
            qs = qs.filter(host__userprofile__is_certified=True)
        if event_type:
            qs = qs.filter(event_type__iexact=event_type)

        # Use semantic search if enabled and no basic results found
        if use_semantic and query and qs.count() == 0:
            try:
                events_list = list(StudyEvent.objects.all())
                semantic_results = semantic_search(query, events_list)
                if semantic_results:
                    semantic_ids = [str(event.id) for event in semantic_results]
                    qs = StudyEvent.objects.filter(id__in=semantic_ids)
            except Exception as e:
                print(f"Semantic search error: {e}")

        # Build JSON response data
        data = []
        for event in qs:
            data.append({
                "id": str(event.id),
                "title": event.title,
                "description": event.description or "",
                "latitude": event.latitude,
                "longitude": event.longitude,
                "time": event.time.isoformat(),
                "end_time": event.end_time.isoformat(),
                "host": event.host.username,
                "hostIsCertified": event.host.userprofile.is_certified,
                "isPublic": event.is_public,
                "event_type": event.event_type.lower() if event.event_type else "other",
                "invitedFriends": list(event.invited_friends.values_list("username", flat=True)),
                "attendees": list(event.attendees.values_list("username", flat=True)),
            })

        return JsonResponse({"events": data}, safe=False)
    return JsonResponse({"error": "Invalid request method"}, status=405)

@csrf_exempt
def certify_user(request):
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            username = data.get("username")
            # You can add extra verification here (like an admin secret or document verification)
            user = User.objects.get(username=username)
            user.userprofile.is_certified = True
            user.userprofile.save()
            return JsonResponse({"success": True, "message": f"User {username} certified."}, status=200)
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)
    return JsonResponse({"error": "Invalid request method."}, status=405)



# -----------------------------
# Invitation Endpoints
# -----------------------------

@csrf_exempt
def decline_invitation(request):
    """
    Declines an invitation and records it in the DeclinedInvitation model.
    Expected JSON:
    {
      "username": "invitedUser",
      "event_id": "<UUID-string>"
    }
    """
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            username = data.get("username")
            event_id = data.get("event_id")
            
            print(f"üîç Processing decline request: username={username}, event_id={event_id}")
            
            user = User.objects.get(username=username)
            event = StudyEvent.objects.get(id=event_id)
            
            # First, remove the user from invited_friends
            if user in event.invited_friends.all():
                event.invited_friends.remove(user)
                print(f"‚úÖ Removed {username} from invited_friends")
            else:
                print(f"‚ö†Ô∏è {username} was not in invited_friends for this event")
            
            # Then, create a DeclinedInvitation record
            declined, created = DeclinedInvitation.objects.get_or_create(user=user, event=event)
            if created:
                print(f"‚úÖ Created new decline record for {username} on event {event.id}")
            else:
                print(f"‚ÑπÔ∏è {username} had already declined event {event.id}")
                
            event.save()
            
            return JsonResponse({
                "success": True, 
                "message": "Invitation declined",
                "event_id": str(event.id)
            }, status=200)
        except User.DoesNotExist:
            print(f"‚ùå User not found: {username}")
            return JsonResponse({"error": "User not found"}, status=404)
        except StudyEvent.DoesNotExist:
            print(f"‚ùå Event not found: {event_id}")
            return JsonResponse({"error": "Event not found"}, status=404)
        except Exception as e:
            print(f"‚ùå Error processing decline: {str(e)}")
            return JsonResponse({"error": str(e)}, status=500)
    return JsonResponse({"error": "Invalid request method"}, status=405)


@csrf_exempt
def get_invitations(request, username):
    """
    Returns events where the user was invited but has not yet accepted
    Includes is_auto_matched flag to differentiate direct invites from potential matches
    """
    try:
        user = User.objects.get(username=username)
        
        # Get all events where user is directly invited
        direct_events = StudyEvent.objects.filter(invited_friends=user) \
                                     .exclude(attendees=user) \
                                     .exclude(host=user)
        
        # Get all auto-matched events (that may not have user in invited_friends)
        auto_matched_invitations = EventInvitation.objects.filter(user=user, is_auto_matched=True)
        auto_matched_event_ids = [inv.event_id for inv in auto_matched_invitations]
        auto_matched_events = StudyEvent.objects.filter(id__in=auto_matched_event_ids) \
                                         .exclude(attendees=user) \
                                         .exclude(host=user)
        
        # Combine both event sets to get all events
        all_event_ids = set(direct_events.values_list('id', flat=True)) | set(auto_matched_events.values_list('id', flat=True))
        all_events = StudyEvent.objects.filter(id__in=all_event_ids)
        
        print(f"‚úÖ Found {direct_events.count()} direct invitations and {auto_matched_events.count()} auto-matched invitations for {username}")
        
        invitation_data = []
        for event in all_events:
            # Check if this is an auto-matched invitation
            try:
                invitation = EventInvitation.objects.get(event=event, user=user)
                is_auto_matched = invitation.is_auto_matched
            except EventInvitation.DoesNotExist:
                # If no invitation record exists, it's a direct invite
                is_auto_matched = False
                
            invitation_data.append({
                "id": str(event.id),
                "title": event.title,
                "description": event.description or "",
                "latitude": event.latitude,
                "longitude": event.longitude,
                "time": event.time.isoformat(),
                "end_time": event.end_time.isoformat(),
                "host": event.host.username,
                "hostIsCertified": event.host.userprofile.is_certified,
                "isPublic": event.is_public,
                "event_type": event.event_type,
                "isAutoMatched": is_auto_matched,  # Changed to camelCase to match Android expectation
                "invitedFriends": list(event.invited_friends.values_list("username", flat=True)),
                "attendees": list(event.attendees.values_list("username", flat=True)),
            })
        
        return JsonResponse({"invitations": invitation_data}, safe=False)
    except User.DoesNotExist:
        return JsonResponse({"error": "User not found"}, status=404)
    except Exception as e:
        print(f"‚ùå Error getting invitations: {str(e)}")
        return JsonResponse({"error": str(e)}, status=500)



from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.models import User
from .models import StudyEvent, EventComment, EventLike, EventShare
import json
import uuid

# Simplified and debug-focused version of add_event_comment

from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse
import json
import uuid
import traceback
from django.contrib.auth.models import User
from .models import StudyEvent, EventComment

@csrf_exempt
def add_event_comment(request):
    """
    Simplified comment endpoint with extensive error tracking
    """
    if request.method == "POST":
        # Log the raw request body for debugging
        raw_body = request.body.decode('utf-8')
        print(f"RAW REQUEST BODY: {raw_body}")
        
        try:
            # Parse JSON with error handling
            try:
                data = json.loads(raw_body)
            except json.JSONDecodeError as e:
                print(f"JSON Parse Error: {e}")
                return JsonResponse({"error": f"Invalid JSON: {str(e)}"}, status=400)
                
            # Extract and validate required fields
            username = data.get("username")
            event_id = data.get("event_id")
            text = data.get("text")
            parent_id = data.get("parent_id")
            
            print(f"Comment data: username={username}, event_id={event_id}, text={text}, parent_id={parent_id}")
            
            if not all([username, event_id, text]):
                return JsonResponse({
                    "error": "Missing required fields",
                    "fields": {
                        "username": bool(username),
                        "event_id": bool(event_id),
                        "text": bool(text)
                    }
                }, status=400)
            
            # Find user
            try:
                user = User.objects.get(username=username)
            except User.DoesNotExist:
                print(f"User not found: {username}")
                return JsonResponse({"error": f"User '{username}' not found"}, status=404)
            
            # Parse event UUID
            try:
                event_uuid = uuid.UUID(event_id)
            except ValueError:
                print(f"Invalid UUID format: {event_id}")
                return JsonResponse({"error": f"Invalid event ID format: {event_id}"}, status=400)
            
            # Find event
            try:
                event = StudyEvent.objects.get(id=event_uuid)
            except StudyEvent.DoesNotExist:
                print(f"Event not found: {event_uuid}")
                return JsonResponse({"error": f"Event with ID {event_id} not found"}, status=404)
            
            # Handle parent comment if provided
            parent = None
            if parent_id:
                try:
                    parent = EventComment.objects.get(id=parent_id)
                except EventComment.DoesNotExist:
                    print(f"Parent comment not found: {parent_id}")
                    return JsonResponse({"error": f"Parent comment {parent_id} not found"}, status=404)
                except ValueError:
                    print(f"Invalid parent ID format: {parent_id}")
                    return JsonResponse({"error": f"Invalid parent ID format: {parent_id}"}, status=400)
            
            # Create the comment
            try:
                comment = EventComment.objects.create(
                    event=event,
                    user=user,
                    text=text,
                    parent=parent
                )
                print(f"Created comment with ID: {comment.id}")
            except Exception as e:
                print(f"Error creating comment: {e}")
                traceback.print_exc()
                return JsonResponse({"error": f"Error creating comment: {str(e)}"}, status=500)
            
            # Return the successful response
            return JsonResponse({
                "success": True,
                "post": {
                    "id": comment.id,
                    "text": comment.text,
                    "username": user.username,
                    "created_at": comment.created_at.isoformat(),
                    "imageURLs": None,
                    "likes": 0,
                    "isLikedByCurrentUser": False,
                    "replies": []
                }
            })
        
        except Exception as e:
            # Catch-all for any other errors
            print(f"Unexpected error in add_event_comment: {e}")
            traceback.print_exc()
            return JsonResponse({"error": f"Server error: {str(e)}"}, status=500)
    
    # Handle non-POST requests
    return JsonResponse({"error": f"Method {request.method} not allowed"}, status=405)

@csrf_exempt
def toggle_event_like(request):
    """
    Like or unlike an event or post with comprehensive error handling and logging
    """
    if request.method == "POST":
        # Enhanced logging of raw request
        raw_body = request.body.decode('utf-8')
        print(f"üîç FULL LIKE REQUEST: {raw_body}")
        
        try:
            data = json.loads(raw_body)
            username = data.get("username")
            event_id = data.get("event_id")
            post_id = data.get("post_id")  # Optional

            # Comprehensive input validation
            if not username or not event_id:
                print("‚ùå Missing required username or event_id")
                return JsonResponse({
                    "error": "Missing required fields", 
                    "details": {
                        "username": bool(username),
                        "event_id": bool(event_id)
                    }
                }, status=400)

            # Fetch user and event with error handling
            try:
                user = User.objects.get(username=username)
                event = StudyEvent.objects.get(id=uuid.UUID(event_id))
            except User.DoesNotExist:
                print(f"‚ùå User not found: {username}")
                return JsonResponse({"error": "User not found"}, status=404)
            except StudyEvent.DoesNotExist:
                print(f"‚ùå Event not found: {event_id}")
                return JsonResponse({"error": "Event not found"}, status=404)

            # Like/Unlike Logic
            if post_id:
                # Post/Comment Like Logic
                try:
                    comment = EventComment.objects.get(id=post_id)
                    like_query = EventLike.objects.filter(
                        user=user, 
                        event=event,
                        comment=comment
                    )
                    
                    if like_query.exists():
                        # Unlike
                        like_query.delete()
                        liked = False
                    else:
                        # Like
                        EventLike.objects.create(
                            user=user, 
                            event=event,
                            comment=comment
                        )
                        liked = True
                        
                    # Comprehensive likes calculation
                    total_likes = EventLike.objects.filter(
                        event=event,
                        comment=comment
                    ).count()
                    
                    print(f"‚úÖ Comment Like: liked={liked}, total_likes={total_likes}")
                    
                except EventComment.DoesNotExist:
                    print(f"‚ùå Comment not found: {post_id}")
                    return JsonResponse({"error": "Comment not found"}, status=404)
                
            else:
                # Event Like Logic
                like_query = EventLike.objects.filter(
                    user=user, 
                    event=event,
                    comment__isnull=True
                )

                if like_query.exists():
                    # Unlike
                    like_query.delete()
                    liked = False
                else:
                    # Like
                    EventLike.objects.create(
                        user=user, 
                        event=event
                    )
                    liked = True
                
                # Event-level likes calculation
                total_likes = EventLike.objects.filter(
                    event=event,
                    comment__isnull=True
                ).count()
                
                print(f"‚úÖ Event Like: liked={liked}, total_likes={total_likes}")

            # Detailed response with likes information
            return JsonResponse({
                "success": True,
                "liked": liked,  # Boolean indicating if user now likes
                "total_likes": total_likes,  # Total number of likes
                "event_id": str(event_id),  # Echo back event ID for frontend reference
                "username": username  # Echo back username
            })

        except json.JSONDecodeError:
            print("‚ùå Invalid JSON data")
            return JsonResponse({"error": "Invalid JSON data"}, status=400)
        except Exception as e:
            print(f"‚ùå Unexpected error in toggle_event_like: {e}")
            import traceback
            traceback.print_exc()
            return JsonResponse({"error": str(e)}, status=500)
    
    return JsonResponse({"error": "Invalid request method"}, status=405)

@csrf_exempt
def record_event_share(request):
    """
    Record an event share
    Expected JSON:
    {
        "username": "johndoe",
        "event_id": "<event-uuid>",
        "platform": "whatsapp"  # whatsapp, facebook, twitter, instagram, other
    }
    """
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            username = data.get("username")
            event_id = data.get("event_id")
            platform = data.get("platform", "other")

            # Validate input
            if not username or not event_id:
                return JsonResponse({"error": "Missing required fields"}, status=400)

            # Fetch user and event
            user = User.objects.get(username=username)
            event = StudyEvent.objects.get(id=uuid.UUID(event_id))

            # Create share record
            share = EventShare.objects.create(
                user=user,
                event=event,
                shared_platform=platform
            )

            # Get total shares
            total_shares = EventShare.objects.filter(event=event).count()

            return JsonResponse({
                "success": True,
                "total_shares": total_shares
            })

        except User.DoesNotExist:
            return JsonResponse({"error": "User not found"}, status=404)
        except StudyEvent.DoesNotExist:
            return JsonResponse({"error": "Event not found"}, status=404)
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)
    
    return JsonResponse({"error": "Invalid request method"}, status=405)

def get_event_interactions(request, event_id):
    """
    Retrieve all interactions (comments, likes, shares) for a specific event
    with detailed like tracking
    """
    try:
        event = StudyEvent.objects.get(id=uuid.UUID(event_id))

        # Detailed comment like tracking
        def get_nested_comments(parent=None):
            base_comments = EventComment.objects.filter(
                event=event, 
                parent=parent
            ).order_by('created_at')
            
            comments_data = []
            for comment in base_comments:
                # Count likes for this specific comment
                comment_likes = EventLike.objects.filter(
                    event=event, 
                    comment=comment
                ).count()
                
                # Debug print for comment likes
                print(f"üîç Comment {comment.id} Likes: {comment_likes}")
                
                comment_data = {
                    "id": comment.id,
                    "text": comment.text,
                    "username": comment.user.username,
                    "created_at": comment.created_at.isoformat(),
                    "likes": comment_likes,  # Add like count
                    "replies": get_nested_comments(comment)
                }
                comments_data.append(comment_data)
            
            return comments_data

        # Root level comments with likes
        comments = get_nested_comments()

        # Event-level likes (without comments)
        event_likes = EventLike.objects.filter(event=event, comment__isnull=True).count()
        print(f"üåü Event {event_id} Total Likes: {event_likes}")

        # Detailed likes tracking
        likes_by_user = {}
        for like in EventLike.objects.filter(event=event):
            username = like.user.username
            if like.comment:
                # Comment-specific like
                if username not in likes_by_user:
                    likes_by_user[username] = {"event_likes": 0, "comment_likes": 0}
                likes_by_user[username]["comment_likes"] += 1
            else:
                # Event-level like
                if username not in likes_by_user:
                    likes_by_user[username] = {"event_likes": 0, "comment_likes": 0}
                likes_by_user[username]["event_likes"] += 1

        # Debug print for likes breakdown
        print("üìä Likes Breakdown:")
        for username, likes in likes_by_user.items():
            print(f"   {username}: Event Likes = {likes['event_likes']}, Comment Likes = {likes['comment_likes']}")

        # Shares breakdown
        shares_breakdown = {}
        shares = EventShare.objects.filter(event=event)
        for platform in ['whatsapp', 'facebook', 'twitter', 'instagram', 'other']:
            shares_breakdown[platform] = shares.filter(shared_platform=platform).count()

        return JsonResponse({
            "comments": comments,
            "likes": {
                "total": event_likes,
                "users": list(likes_by_user.keys()),
                "detailed_breakdown": likes_by_user
            },
            "shares": {
                "total": shares.count(),
                "breakdown": shares_breakdown
            }
        })

    except StudyEvent.DoesNotExist:
        return JsonResponse({"error": "Event not found"}, status=404)
    except Exception as e:
        print(f"‚ùå Error in get_event_interactions: {str(e)}")
        return JsonResponse({"error": str(e)}, status=500)

# Add these functions to your views.py file

def get_event_feed(request, event_id):
    """
    Retrieve event feed data (posts, likes, shares) in the format expected by the new Swift implementation.
    This combines comments, likes, and shares into the new Posts structure.
    """
    try:
        # Convert string ID to UUID
        event = StudyEvent.objects.get(id=uuid.UUID(event_id))
        
        # Get all comments (sorted by newest first)
        comments = EventComment.objects.filter(event=event, parent=None).order_by('-created_at')
        
        # Get likes data
        likes_total = EventLike.objects.filter(event=event).count()
        likes_users = list(EventLike.objects.filter(event=event).values_list('user__username', flat=True))
        
        # Get shares data
        shares_total = EventShare.objects.filter(event=event).count()
        
        # Build shares breakdown
        shares_breakdown = {}
        for platform in ['whatsapp', 'facebook', 'twitter', 'instagram', 'other']:
            shares_breakdown[platform] = EventShare.objects.filter(
                event=event, 
                shared_platform=platform
            ).count()
        
        # Format posts data in the format expected by the Swift implementation
        posts_data = []
        for comment in comments:
            # Check if the current user liked this comment (if passed in request)
            current_user = request.GET.get('current_user', None)
            is_liked = False
            
            if current_user:
                try:
                    user = User.objects.get(username=current_user)
                    is_liked = EventLike.objects.filter(
                        user=user, 
                        event=event, 
                        comment_id=comment.id
                    ).exists()
                except User.DoesNotExist:
                    pass
            
            # Get replies for this comment
            replies = []
            for reply in EventComment.objects.filter(parent=comment).order_by('created_at'):
                replies.append({
                    "id": reply.id,
                    "text": reply.text,
                    "username": reply.user.username,
                    "created_at": reply.created_at.isoformat(),
                    "imageURLs": None,  # Add image handling if needed
                    "likes": 0,  # Add likes count for replies if implementing
                    "isLikedByCurrentUser": False,  # Add current user like check if implementing
                    "replies": []  # We don't support nested replies beyond 1 level
                })
            
            # Build the post structure
            post = {
                "id": comment.id,
                "text": comment.text,
                "username": comment.user.username,
                "created_at": comment.created_at.isoformat(),
                "imageURLs": None,  # Add image handling if needed
                "likes": 0,  # Add like count for each post if implementing 
                "isLikedByCurrentUser": is_liked,
                "replies": replies
            }
            posts_data.append(post)
        
        # Return the event feed data
        return JsonResponse({
            "posts": posts_data,
            "likes": {
                "total": likes_total,
                "users": likes_users
            },
            "shares": {
                "total": shares_total,
                "breakdown": shares_breakdown
            }
        })
        
    except StudyEvent.DoesNotExist:
        return JsonResponse({"error": "Event not found"}, status=404)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

# Update the add_event_comment function to support post creation with images
@csrf_exempt
def add_event_comment(request):
    """
    Add a comment/post to an event, possibly with images
    Expected JSON:
    {
        "username": "johndoe",
        "event_id": "<event-uuid>",
        "text": "Great event!",
        "parent_id": null,  # optional, for replies
        "image_urls": []    # optional, for posts with images
    }
    """
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            username = data.get("username")
            event_id = data.get("event_id")
            text = data.get("text")
            parent_id = data.get("parent_id")
            image_urls = data.get("image_urls", [])  # List of image URLs if any

            # Validate input
            if not username or not event_id or not text:
                return JsonResponse({"error": "Missing required fields"}, status=400)

            # Fetch user and event
            user = User.objects.get(username=username)
            event = StudyEvent.objects.get(id=uuid.UUID(event_id))

            # Create comment/post
            if parent_id:
                # This is a reply
                parent_comment = EventComment.objects.get(id=parent_id)
                comment = EventComment.objects.create(
                    event=event,
                    user=user,
                    text=text,
                    parent=parent_comment
                )
            else:
                # This is a top-level post
                comment = EventComment.objects.create(
                    event=event,
                    user=user,
                    text=text
                )
            
            # If the post has images, store them
            # Note: You need to implement image storage if needed
            # This is just a placeholder for how you might handle it
            if image_urls and len(image_urls) > 0:
                # Store image URLs in a related model or as JSON in a field
                # Example: EventImage.objects.create(comment=comment, image_url=url)
                pass

            # Return the created post data
            return JsonResponse({
                "success": True,
                "post": {
                    "id": comment.id,
                    "text": comment.text,
                    "username": comment.user.username,
                    "created_at": comment.created_at.isoformat(),
                    "imageURLs": image_urls if image_urls else None,
                    "likes": 0,
                    "isLikedByCurrentUser": False,
                    "replies": []
                }
            }, status=201)

        except User.DoesNotExist:
            return JsonResponse({"error": "User not found"}, status=404)
        except StudyEvent.DoesNotExist:
            return JsonResponse({"error": "Event not found"}, status=404)
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)
    
    return JsonResponse({"error": "Invalid request method"}, status=405)

# Update the event like function to handle post likes
@csrf_exempt
def toggle_event_like(request):
    """
    Like or unlike an event or post
    Expected JSON:
    {
        "username": "johndoe",
        "event_id": "<event-uuid>",
        "post_id": null  # optional, if liking a specific post rather than the event
    }
    """
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            username = data.get("username")
            event_id = data.get("event_id")
            post_id = data.get("post_id")  # This is optional

            # Validate input
            if not username or not event_id:
                return JsonResponse({"error": "Missing required fields"}, status=400)

            # Fetch user and event
            user = User.objects.get(username=username)
            event = StudyEvent.objects.get(id=uuid.UUID(event_id))

            # Check if this is a post like or an event like
            if post_id:
                # This is a post like - modify this to fit your models
                # For simplicity, we're just assuming there's a CommentLike model
                try:
                    comment = EventComment.objects.get(id=post_id)
                    existing_like = EventLike.objects.filter(
                        user=user, 
                        event=event,
                        comment=comment
                    )
                    
                    if existing_like.exists():
                        # Unlike
                        existing_like.delete()
                        liked = False
                    else:
                        # Like
                        EventLike.objects.create(
                            user=user, 
                            event=event,
                            comment=comment
                        )
                        liked = True
                        
                    # Get total likes for this post
                    total_likes = EventLike.objects.filter(
                        event=event,
                        comment=comment
                    ).count()
                    
                except EventComment.DoesNotExist:
                    return JsonResponse({"error": "Post not found"}, status=404)
                
            else:
                # This is an event like
                existing_like = EventLike.objects.filter(
                    user=user, 
                    event=event,
                    comment__isnull=True
                )

                if existing_like.exists():
                    # Unlike
                    existing_like.delete()
                    liked = False
                else:
                    # Like
                    EventLike.objects.create(
                        user=user, 
                        event=event
                    )
                    liked = True
                
                # Get total likes for the event
                total_likes = EventLike.objects.filter(
                    event=event,
                    comment__isnull=True
                ).count()

            return JsonResponse({
                "success": True,
                "liked": liked,
                "total_likes": total_likes
            })

        except User.DoesNotExist:
            return JsonResponse({"error": "User not found"}, status=404)
        except StudyEvent.DoesNotExist:
            return JsonResponse({"error": "Event not found"}, status=404)
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)
    
    return JsonResponse({"error": "Invalid request method"}, status=405)


from django.http import JsonResponse
from django.contrib.auth.models import User

def perform_auto_matching(event_id, max_invites=10, radius_km=10.0, min_interest_match=1):
    """Helper function to perform auto-matching logic"""
    from myapp.models import StudyEvent, UserProfile
    
    try:
        event = StudyEvent.objects.get(id=event_id)
    except StudyEvent.DoesNotExist:
        return {"error": "Event not found"}, 404
    
    # Get event details needed for matching
    event_host = event.host
    event_interests = event.interest_tags if hasattr(event, 'interest_tags') else []
    
    # Get users who have auto-invite enabled and filter out the host and already invited/attending users
    potential_users = UserProfile.objects.filter(auto_invite_enabled=True) \
        .exclude(user=event_host) \
        .exclude(user__in=event.invited_friends.all()) \
        .exclude(user__in=event.attendees.all())
    
    matched_users = []
    
    # Calculate matching scores
    for profile in potential_users:
        user_interests = profile.get_interests()
        
        # Skip if user has no interests
        if not user_interests:
            continue
        
        # Calculate matching interests
        matching_interests = set(user_interests).intersection(set(event_interests))
        
        # Skip if not enough matching interests
        if len(matching_interests) < min_interest_match:
            continue
        
        # Create a match score
        match_score = 0
        match_score += len(matching_interests) * 10  # 10 points per matching interest
        
        # Add location score if available (would need to be implemented)
        # This is just a placeholder - actual implementation would need user location
        
        matched_users.append({
            "username": profile.user.username,
            "match_score": match_score,
            "matching_interests": list(matching_interests),
            "invited": False
        })
    
    # Sort by match score
    matched_users.sort(key=lambda x: x["match_score"], reverse=True)
    
    # Limit to max_invites
    matched_users = matched_users[:max_invites]
    
    # Send invites
    invites_sent = 0
    for match in matched_users:
        try:
            user = User.objects.get(username=match["username"])
            event.invited_friends.add(user)
            match["invited"] = True
            invites_sent += 1
        except Exception as e:
            print(f"Error inviting user {match['username']}: {str(e)}")
    
    return {
        "success": True,
        "matched_users": matched_users,
        "total_invites_sent": invites_sent,
        "message": f"Successfully matched and invited {invites_sent} users"
    }, 200


import json
import uuid
import logging
from datetime import timedelta
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.models import User
from django.utils import timezone
from django.db.models import Count, Q
from .models import StudyEvent, UserProfile

# Configure logging
logger = logging.getLogger(__name__)

def text_similarity(text1, text2):
    """Simple text similarity based on word overlap"""
    if not text1 or not text2:
        return 0.0
    
    # Convert to lowercase and split by spaces
    words1 = set(text1.lower().split())
    words2 = set(text2.lower().split())
    
    # Calculate Jaccard similarity
    intersection = len(words1.intersection(words2))
    union = len(words1.union(words2))
    
    if union == 0:
        return 0.0
    return intersection / union

def calculate_distance(lat1, lon1, lat2, lon2):
    """
    Calculate distance between two coordinates using Haversine formula
    Returns distance in kilometers
    """
    from math import radians, sin, cos, sqrt, atan2
    
    # Convert to radians
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    
    # Haversine formula
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    r = 6371  # Radius of Earth in kilometers
    
    return r * c

@csrf_exempt
def advanced_auto_match(request):
    """
    Advanced auto-matching algorithm that considers multiple factors
    """
    if request.method != "POST":
        return JsonResponse({"error": "Method not allowed"}, status=405)
    
    try:
        # Parse and validate input
        data = json.loads(request.body)
        event_id = data.get("event_id")
        max_invites = int(data.get("max_invites", 10))
        min_score = float(data.get("min_score", 30.0))
        potentials_only = data.get("potentials_only", False)  # New parameter
        
        print(f"üîç Processing advanced auto-match for event {event_id}, max_invites={max_invites}, potentials_only={potentials_only}")
        
        if not event_id:
            return JsonResponse({"error": "Event ID is required"}, status=400)
            
        # Get the event
        try:
            event = StudyEvent.objects.get(id=uuid.UUID(event_id))
        except (StudyEvent.DoesNotExist, ValueError):
            print(f"‚ùå Event not found or invalid ID: {event_id}")
            return JsonResponse({"error": "Event not found or invalid ID"}, status=404)
        
        # Get event details for matching
        event_host = event.host
        event_interests = event.get_interest_tags() if hasattr(event, 'get_interest_tags') else []
        
        # Get existing invitees and attendees to exclude them
        existing_users = set()
        existing_users.add(event_host.id)  # Exclude the host
        existing_users.update([inv.user.id for inv in EventInvitation.objects.filter(event=event)])
        existing_users.update(event.attendees.values_list('id', flat=True))
        
        # Get potential users who have auto-invite enabled
        potential_profiles = UserProfile.objects.filter(
            auto_invite_enabled=True
        ).exclude(
            user__id__in=existing_users
        )
        
        # Calculate match scores for each potential user
        matched_users = []
        
        for profile in potential_profiles:
            user = profile.user
            match_score = 0.0
            
            # Interest matching
            user_interests = profile.get_interests()
            matching_interests = set(user_interests).intersection(set(event_interests))
            
            interest_score = len(matching_interests) * 10
            match_score += interest_score
            
            # Only consider users who meet the minimum score threshold
            if match_score >= min_score:
                matched_users.append({
                    "user_id": user.id,
                    "username": user.username,
                    "match_score": match_score,
                    "matching_interests": list(matching_interests)
                })
        
        # Sort by match score (highest first)
        matched_users.sort(key=lambda x: x["match_score"], reverse=True)
        
        # Limit to max_invites
        top_matches = matched_users[:max_invites]
        
        # If potentials_only is True, just return the potential matches without inviting
        if potentials_only:
            return JsonResponse({
                "success": True,
                "potential_matches": top_matches,
                "total_potential_matches": len(matched_users),
                "event_id": str(event.id),
                "event_title": event.title
            })
        
        # Send invites
        invites_sent = 0
        for match in top_matches:
            try:
                user = User.objects.get(id=match["user_id"])
                
                # Create invitation with is_auto_matched=True
                invitation, created = EventInvitation.objects.get_or_create(
                    event=event,
                    user=user,
                    defaults={"is_auto_matched": True}
                )
                
                if created:
                    print(f"‚úÖ Advanced auto-matched and invited {user.username} to event {event.id}")
                    invites_sent += 1
                    match["invited"] = True
                else:
                    print(f"‚ÑπÔ∏è User {user.username} was already invited to event {event.id}")
                    match["invited"] = False
            except Exception as e:
                match["invited"] = False
                match["error"] = str(e)
                print(f"‚ùå Error inviting user {match['username']}: {str(e)}")
        
        # Return results
        return JsonResponse({
            "success": True,
            "event": {
                "id": str(event.id),
                "title": event.title,
                "host": event_host.username
            },
            "matched_users": top_matches,
            "total_potential_matches": len(matched_users),
            "invites_sent": invites_sent,
            "message": f"Successfully matched and invited {invites_sent} users"
        })
        
    except json.JSONDecodeError:
        return JsonResponse({"error": "Invalid JSON data"}, status=400)
    except Exception as e:
        print(f"‚ùå Unexpected error in advanced_auto_match: {str(e)}")
        import traceback
        traceback.print_exc()
        return JsonResponse({"error": str(e)}, status=500)

@csrf_exempt
def invite_to_event(request):
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            event_id = data.get("event_id")
            username = data.get("username")
            is_auto_matched = data.get("mark_as_auto_matched", False)  # Get auto-matched flag
            
            print(f"üîç Processing invitation: username={username}, event_id={event_id}, auto-matched={is_auto_matched}")
            
            # Get the event and user
            try:
                event = StudyEvent.objects.get(id=uuid.UUID(event_id))
                user = User.objects.get(username=username)
            except StudyEvent.DoesNotExist:
                return JsonResponse({"error": "Event not found"}, status=404)
            except User.DoesNotExist:
                return JsonResponse({"error": "User not found"}, status=404)
            except ValueError:
                return JsonResponse({"error": "Invalid event ID format"}, status=400)
            
            # Use the convenience method to invite
            event.invite_user(user, is_auto_matched)
            
            return JsonResponse({
                "success": True,
                "message": f"User {username} invited to event successfully",
                "is_auto_matched": is_auto_matched
            })
            
        except json.JSONDecodeError:
            return JsonResponse({"error": "Invalid JSON data"}, status=400)
        except Exception as e:
            print(f"‚ùå Error inviting user: {str(e)}")
            return JsonResponse({"error": str(e)}, status=500)
    
    return JsonResponse({"error": "Invalid request method"}, status=405)

@csrf_exempt
def update_user_interests(request):
    """
    Update a user's profile with interests, skills, and preferences
    
    Expected JSON payload:
    {
        "username": "username",
        "interests": ["interest1", "interest2", ...],
        "skills": {"skill1": "BEGINNER", "skill2": "ADVANCED", ...},
        "auto_invite_preference": true,
        "preferred_radius": 10.0
    }
    """
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            username = data.get("username")
            interests = data.get("interests", [])
            skills = data.get("skills", {})
            auto_invite_preference = data.get("auto_invite_preference", True)
            preferred_radius = data.get("preferred_radius", 10.0)
            
            print(f"üîç Updating preferences for user: {username}")
            print(f"  Interests: {interests}")
            print(f"  Skills: {skills}")
            print(f"  Auto-invite: {auto_invite_preference}")
            print(f"  Preferred radius: {preferred_radius}")
            
            # Find the user
            try:
                user = User.objects.get(username=username)
            except User.DoesNotExist:
                print(f"‚ùå User not found: {username}")
                return JsonResponse({"error": "User not found"}, status=404)
            
            # Get or create the user profile
            profile, created = UserProfile.objects.get_or_create(user=user)
            
            # Update the profile fields
            # Store interests as a comma-separated list or using the model's method
            if hasattr(profile, 'set_interests'):
                profile.set_interests(interests)
            
            # Store skills as a JSON string or using the model's method
            if hasattr(profile, 'set_skills'):
                profile.set_skills(skills)
            
            # Update auto-invite preference if the field exists
            if hasattr(profile, 'auto_invite_enabled'):
                profile.auto_invite_enabled = auto_invite_preference
            
            # Update preferred radius if the field exists
            if hasattr(profile, 'preferred_radius'):
                profile.preferred_radius = preferred_radius
            
            # Save the profile
            profile.save()
            
            print(f"‚úÖ Successfully updated profile for {username}")
            
            return JsonResponse({
                "success": True,
                "message": "User interests and preferences updated successfully"
            })
            
        except json.JSONDecodeError:
            print("‚ùå Invalid JSON data")
            return JsonResponse({"error": "Invalid JSON data"}, status=400)
        except Exception as e:
            print(f"‚ùå Error updating user interests: {str(e)}")
            import traceback
            traceback.print_exc()
            return JsonResponse({"error": str(e)}, status=500)
    
    return JsonResponse({"error": "Invalid request method"}, status=405)


"""
Auto-matched users endpoint for the PinIt app.
Add this function to your Django backend's views.py file.
"""
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from .models import User, StudyEvent, EventInvitation

def get_auto_matched_users(request, event_id):
    """
    Get users who were auto-matched for a specific event.
    
    Parameters:
    - event_id: The UUID of the event to check
    
    Returns:
    JSON response with a list of usernames that were auto-matched.
    """
    try:
        # Get the event
        event = StudyEvent.objects.get(id=event_id)
        
        # Get all auto-matched invitations for this event
        auto_matched_invitations = EventInvitation.objects.filter(
            event=event,
            is_auto_matched=True
        )
        
        # Extract the usernames
        auto_matched_users = [invitation.user.username for invitation in auto_matched_invitations]
        
        return JsonResponse({
            'success': True,
            'event_id': event_id,
            'auto_matched_users': auto_matched_users,
            'count': len(auto_matched_users)
        })
        
    except StudyEvent.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': f'Event with ID {event_id} not found'
        }, status=404)
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

# Add this to your urls.py file:
"""
Add this code to your Django view function that gets invitations to debug the auto-matching issue.
Insert it at the beginning of the get_invitations function.
"""

